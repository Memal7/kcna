# Kubernetes Objects
This part of the repository demonstrate the **Kubernetes Objects** which is the part of [Kubernetes Fundamentals - 46%](./03_kubernetes-fundamentals.md).

---

## Chapter outcomes
- Describe the Kubernetes Objects and understand the task of every single object in much details and deep dive.

---

## What're Kubernetes (k8s) objects?
- K8s objects are a collection of primitives to represent the state of whole cluster and allow to configure (declarative or imperative) the state of the cluster.
- A k8s object is a "record of intent" - once you create the object, the k8s system will constantly work to ensure that object exists.
- By creating an object, you're effectively telling the k8s system what you want your cluster's workload to look like; this is your cluster's desired state.
- These objects describe how your workload should be handled and how to handle container orchestration issues like scheduling, self-healing, etc.
- Some core primitives K8s objects are:
    - **Pods:** where the containerized application instance run. 
    - **Controller:** keeps whole cluster in desired state (e.g. Deployments, ReplicaSet, etc.).
    - **Service:** provides a persistence access point to the containerized application inside Pods (e.g. Ingress, etc.).
    - **Storage:** provides persistence storage solution (e.g. Volume, PV, PVC, etc.).
- Objects can be described in YAML file and then send them to API Server, where going to be validated before they're created.
- An example k8s object declaration in YAML file looks like followings:
```
apiVersion: demo-app/v1 
kind: Deployment   
metadata:  
  name: nginx-deployment  
spec:  
  selector:  
    matchLabels:  
      app: nginx  
  replicas: 3  
  template:  
    metadata:  
     labels:  
       app: nginx  
    spec:  
      containers:  
        - name: sample-nginx-container  
          image: nginx:1.20  
          ports:  
          - containerPort: 80  
```
---

## Describe the concept and task of API Server.
- All communications between all k8s components are done through API Server and this where users would access the cluster.
- Without it, communication with the cluster is not possible!
- It's a `RESTful API` over `HTTP` or `HTTPS` using `JSON`.
- Before a request is processed by k8s, it has to go through three stages:
    - **Authentication:** The requester needs to present a means of identity to authenticate against the API. Commonly done with a digital signed certificate (X.509) or with an external identity management system. K8s users are always externally managed. Service Accounts can be used to authenticate technical users
    - **Authorization:** it is decided what the requester is allowed to do. In k8s this can be done with *Role Based Access Control (RBAC)*.
    - **Admission Control:** can be used to modify or validate the request. E.g., if a user tries to use a container image from an untrustworthy registry, an admission controller could block this request. Tools like the *Open Policy Agent* can be used to manage admission control externally.

---

## Describe Kubernetes Workload objects.
- **Pods:**
    - Pods are the smallest deployable compute unit in k8s and describes a unit of one or more containers that share an isolation layer of `namespaces` and `cgroups`.
    - In a Pod runs usually a single containerized application instance based on a container image, but can contain multiple containers, e.g. including util containers or logging containers.
    - All containers inside a Pod share an IP address and can share via the filesystem.
    - Pods are ephemeral - no Pod is ever re-deployed. If a Pod dies and re-deploy again based on a container image, no state is maintained between those deployments.
    - Pods are atomicity - if a container in a Pod dies, the Pod is unavailable, even for all containers in this Pod.
- **Controller:**
    - Controllers are control loops that watch the state of your cluster, then make or request changes where needed. Each Controller tries to move the current cluster state closer to the desired state.
    - K8s Pods have a defined lifecycle, e.g. a Pod is running in your cluster then a critical fault happens on the Worker Node where that Pod is running, means that all the Pods on that Worker Node fail. You need to create a new Pod to recover, even if the node later becomes healthy.
    - However you don't have to manage each Pod. To make sure that a defined number of Pod copies runs all the time, you can use Controller objects (e.g. Deployment, ReplicaSet, DaemonsSet, etc.) that make sure the right number of the right kind of Pod are always running, to match the desired state you specified.
- **ReplicaSet:**
    - ReplicaSet ensures a desired number of Pods are running at any given time.
    - Define the number of replicas for a particular Pod and make sure if one of the Pod becomes unavailable or unhealthy that you want to have up and running at all times.
    - ReplicaSet can be used to scale out applications and improve their availability. They do this by starting multiple copies of a Pod definition.
- **Deployment:**
    - Deployment manages the state of the ReplicaSet, e.g. things like which container image to run or numbers of Pods to create.
    - Deployment describes the complete application lifecycle by managing multiple ReplicaSets that get updated when the application is changed by providing a new container image.
    - A Deployment is an object that can represent an application running on your cluster. When you create the Deployment, you might set the Deployment spec to specify the number of replicas of the application to be running. The k8s system reads the Deployment spec and starts that desired number of instances of your application - updating the status to match your spec. If any of those instances should fail (a status change), the k8s system responds the difference between spec and status by making a correction - in this case, starting a replacement instance.
    - Deployments are perfect to run stateless applications in k8s.
    - **Deployment strategies:**
        - `recreate:` terminate the old version and release the new one
        - `Ramped (default):` release a new version on a rolling update fashion, one after the other
        - `blue/green:` release a new version alongside the old version then switch traffic
        `canary:` release a new version to a subset of users, then proceed to a full rollout
        - `a/b testing:` release a new version to a subset of users in a precise way (HTTP headers, cookies, weight, etc.).
- **StatefullSet:**
    - StatefulSets can be used to run statefull applications like databases on k8s.
	- Stateful applications have special requirements that don't fit the ephemeral nature of Pods and containers.
    - In contrast to Deployments, StatefulSets try to retain IP addresses of Pods and give them a stable name, persistent storage and more graceful handling of scaling and updates.
- **DaemonSet:**
    - DaemonSet object ensures that a copy of a Pod runs on all (or some) Worker Nodes of your cluster.
    - DaemonSets are perfect to run infrastructure-related workload, e.g. monitoring or logging tools.
- **Job:**
	- Job object creates one or more Pods that execute a task and terminate afterwards.
    - Job objects are perfect to run one-shot scripts like database migrations or administrative tasks.
- **CronJobs:**
	- CronJobs add a time-based configuration to jobs.
    - This allows running jobs periodically, e.g. doing a backup job every night at 4am.

    ![Kubernetes Workload objects](./00_images/k8s-workload-objects.png)

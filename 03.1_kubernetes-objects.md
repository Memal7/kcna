# Kubernetes Objects
This part of the repository demonstrate the **Kubernetes Objects** which is the part of [Kubernetes Fundamentals - 46%](./03_kubernetes-fundamentals.md).

---

## Chapter outcomes
- Describe the Kubernetes Objects and understand the task of every single object in much details and deep dive.

---

## What're Kubernetes (k8s) objects?
- K8s objects are a collection of primitives to represent the state of whole cluster and allow to configure (declarative or imperative) the state of the cluster.
- A k8s object is a "record of intent" - once you create the object, the k8s system will constantly work to ensure that object exists.
- By creating an object, you're effectively telling the k8s system what you want your cluster's workload to look like; this is your cluster's desired state.
- These objects describe how your workload should be handled and how to handle container orchestration issues like scheduling, self-healing, etc.
- Some core primitives K8s objects are:
    - **Pods:** where the containerized application instance run. 
    - **Controller:** keeps whole cluster in desired state (e.g. Deployments, ReplicaSet, etc.).
    - **Service:** provides a persistence access point to the containerized application inside Pods (e.g. Ingress, etc.).
    - **Storage:** provides persistence storage solution (e.g. Volume, PV, PVC, etc.).
- Objects can be described in YAML file and then send them to API Server, where going to be validated before they're created.
- An example k8s object declaration in YAML file looks like followings:
```
apiVersion: demo-app/v1 
kind: Deployment   
metadata:  
  name: nginx-deployment  
spec:  
  selector:  
    matchLabels:  
      app: nginx  
  replicas: 3  
  template:  
    metadata:  
     labels:  
       app: nginx  
    spec:  
      containers:  
        - name: sample-nginx-container  
          image: nginx:1.20  
          ports:  
          - containerPort: 80  
```
---

## Describe the concept and task of API Server.
- All communications between all k8s components are done through API Server and this where users would access the cluster.
- Without it, communication with the cluster is not possible!
- It's a `RESTful API` over `HTTP` or `HTTPS` using `JSON`.
- Before a request is processed by k8s, it has to go through three stages:
    - **Authentication:** The requester needs to present a means of identity to authenticate against the API. Commonly done with a digital signed certificate (X.509) or with an external identity management system. K8s users are always externally managed. Service Accounts can be used to authenticate technical users
    - **Authorization:** it is decided what the requester is allowed to do. In k8s this can be done with *Role Based Access Control (RBAC)*.
    - **Admission Control:** can be used to modify or validate the request. E.g., if a user tries to use a container image from an untrustworthy registry, an admission controller could block this request. Tools like the *Open Policy Agent* can be used to manage admission control externally.

---

## Describe all workload objects.
- **Pods:**
    - Pods are the smallest deployable compute unit in k8s and describes a unit of one or more containers that share an isolation layer of `namespaces` and `cgroups`.
    - In a Pod runs usually a single containerized application instance based on a container image, but can contain multiple containers, e.g. including util containers or logging containers.
    - All containers inside a Pod share an IP address and can share via the filesystem.
    - Pods are ephemeral - no Pod is ever re-deployed. If a Pod dies and re-deploy again based on a container image, no state is maintained between those deployments.
    - Pods are atomicity - if a container in a Pod dies, the Pod is unavailable, even for all containers in this Pod.
- **Controller:**
    - Controllers are control loops that watch the state of your cluster, then make or request changes where needed. Each Controller tries to move the current cluster state closer to the desired state.
    - K8s Pods have a defined lifecycle, e.g. a Pod is running in your cluster then a critical fault happens on the Worker Node where that Pod is running, means that all the Pods on that Worker Node fail. You need to create a new Pod to recover, even if the node later becomes healthy.
    - However you don't have to manage each Pod. To make sure that a defined number of Pod copies runs all the time, you can use Controller objects (e.g. Deployment, ReplicaSet, DaemonsSet, etc.) that make sure the right number of the right kind of Pod are always running, to match the desired state you specified.
- **ReplicaSet:**
    - ReplicaSet ensures a desired number of Pods are running at any given time.
    - Define the number of replicas for a particular Pod and make sure if one of the Pod becomes unavailable or unhealthy that you want to have up and running at all times.
    - ReplicaSet can be used to scale out applications and improve their availability. They do this by starting multiple copies of a Pod definition.
